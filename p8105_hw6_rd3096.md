p8105_hw6_rd3096
================
Timothy Du

# load necessary pakages

``` r
library(tidyverse)
```

    ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
    ## ✔ dplyr     1.1.4     ✔ readr     2.1.5
    ## ✔ forcats   1.0.0     ✔ stringr   1.5.1
    ## ✔ ggplot2   3.5.1     ✔ tibble    3.2.1
    ## ✔ lubridate 1.9.3     ✔ tidyr     1.3.1
    ## ✔ purrr     1.0.2     
    ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
    ## ✖ dplyr::filter() masks stats::filter()
    ## ✖ dplyr::lag()    masks stats::lag()
    ## ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors

``` r
library(rnoaa)
```

    ## The rnoaa package will soon be retired and archived because the underlying APIs have changed dramatically. The package currently works but does not pull the most recent data in all cases. A noaaWeather package is planned as a replacement but the functions will not be interchangeable.

``` r
library(ggplot2)
library(modelr)
library(mgcv)
```

    ## Loading required package: nlme
    ## 
    ## Attaching package: 'nlme'
    ## 
    ## The following object is masked from 'package:dplyr':
    ## 
    ##     collapse
    ## 
    ## This is mgcv 1.9-1. For overview type 'help("mgcv-package")'.

``` r
library(broom)
```

    ## 
    ## Attaching package: 'broom'
    ## 
    ## The following object is masked from 'package:modelr':
    ## 
    ##     bootstrap

``` r
set.seed(1)


knitr::opts_chunk$set(
    echo = TRUE,
    warning = FALSE,
    fig.width = 8, 
  fig.height = 6,
  out.width = "90%"
)

theme_set(theme_minimal() + theme(legend.position = "bottom"))

options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
)

scale_colour_discrete = scale_colour_viridis_d
scale_fill_discrete = scale_fill_viridis_d
```

## problem 1

we need to download the dataset using the code chunk below

``` r
weather_df = 
  rnoaa::meteo_pull_monitors(
    c("USW00094728"),
    var = c("PRCP", "TMIN", "TMAX"), 
    date_min = "2017-01-01",
    date_max = "2017-12-31") %>%
  mutate(
    name = recode(id, USW00094728 = "CentralPark_NY"),
    tmin = tmin / 10,
    tmax = tmax / 10) %>%
  select(name, id, everything())
```

    ## using cached file: /Users/timothysmacbook/Library/Caches/org.R-project.R/R/rnoaa/noaa_ghcnd/USW00094728.dly

    ## date created (size, mb): 2024-11-30 22:30:37.797162 (8.667)

    ## file min/max dates: 1869-01-01 / 2024-11-30

``` r
str(weather_df)
```

    ## tibble [365 × 6] (S3: tbl_df/tbl/data.frame)
    ##  $ name: chr [1:365] "CentralPark_NY" "CentralPark_NY" "CentralPark_NY" "CentralPark_NY" ...
    ##  $ id  : chr [1:365] "USW00094728" "USW00094728" "USW00094728" "USW00094728" ...
    ##  $ date: Date[1:365], format: "2017-01-01" "2017-01-02" ...
    ##  $ prcp: num [1:365] 0 53 147 0 0 13 81 0 0 0 ...
    ##  $ tmax: num [1:365] 8.9 5 6.1 11.1 1.1 0.6 -3.2 -3.8 -4.9 7.8 ...
    ##  $ tmin: num [1:365] 4.4 2.8 3.9 1.1 -2.7 -3.8 -6.6 -8.8 -9.9 -6 ...

Next, we will perform bootstrap sampling and regression analysis.

First, we need to write a function to create the two quantities that we
are interested.

``` r
compute_metrics = function(weather_sample) {
  model = lm(tmax ~ tmin, data = weather_sample)
  r_squared = glance(model)$r.squared
  coefficients = tidy(model)
  intercept = coefficients %>% 
    filter(term == "(Intercept)") %>% 
    pull(estimate)
  
  slope = coefficients %>%
    filter(term == "tmin") %>% 
    pull(estimate)
  
  log_beta_product = log(intercept * slope)
  
  tibble(
    r_squared = r_squared,
    log_beta_product = log_beta_product
  )
}
```

we will perform bootstramp using the map function

``` r
bootstrap_results = 
  weather_df %>%
  modelr::bootstrap (n = 5000) %>% 
  mutate(
    strap = map(strap, as_tibble),
    results = map(strap, compute_metrics)
    ) %>%
  unnest(results)
```

Final step, we will summarize the results and visualize using ggplot

``` r
bootstrap_summary =
  bootstrap_results %>%
  summarise(
    mean_r_squared = mean(r_squared),
    sd_r_squared = sd(r_squared),
    mean_log_beta_product = mean(log_beta_product),
    sd_log_beta_product = sd(log_beta_product)
  )


bootstrap_results %>%
  pivot_longer(
    cols = c(r_squared, log_beta_product), 
    names_to = "metric", 
    values_to = "value"
    ) %>%
  ggplot(aes(x = value)) +
  geom_density(fill = "blue", alpha = 0.7) +
  facet_wrap(. ~ metric, scales = "free") +
  theme_minimal() +
  labs(
    title = "Bootstrap Distributions of r^2 and log(beta0 * beta1)",
    x = "Value",
    y = "Frequency"
  )
```

<img src="p8105_hw6_rd3096_files/figure-gfm/unnamed-chunk-4-1.png" width="90%" /> 1.
Distribution of log(beta_0\*beta_1)

- The plot on the left represents the bootstrap distribution of this
  log_product, where beta_0 is the intercept and beta_1 is the slope.

- Shape: The distribution is approximately symmetric and bell-shaped,
  indicating that the log-transformed product of the intercept and slope
  is fairly stable across the bootstrap samples.

- Range: The values are centered around 2.0, with a slight spread from
  approximately 1.95 to 2.10.

- Interpretation: The logarithm of the product of the intercept and
  slope is consistent and suggests a central tendency (average value)
  close to 2.0.

2.  Distribution of r_square

- The plot on the right represents the bootstrap distribution of
  r_square, the proportion of variance in tmax explained by tmin.

- Shape: This distribution is also symmetric and bell-shaped, showing
  that the r_square values are consistently estimated across bootstrap
  samples.

- Range: The values are tightly centered around 0.91, with a slight
  spread from approximately 0.88 to 0.94.

- Interpretation: The r_square values indicate a strong linear
  relationship between tmin and tmax, with most bootstrap samples
  confirming a high proportion of variance explained.
